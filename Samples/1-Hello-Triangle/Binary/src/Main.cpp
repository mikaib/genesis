// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_4dbe585c96d08098
#define INCLUDED_4dbe585c96d08098
#include "genesis.h"
#endif
#ifndef INCLUDED_66c800784bc86d2f
#define INCLUDED_66c800784bc86d2f
#include "linc_glfw.h"
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_genesis__GsManagedData_GsManagedDataHolder
#include <genesis/_GsManagedData/GsManagedDataHolder.h>
#endif
#ifndef INCLUDED_genesis__GsManagedData_GsManagedData_Impl_
#include <genesis/_GsManagedData/GsManagedData_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_7_main,"Main","main",0xed0e206e,"Main.main","Main.hx",7,0x087e5c05)
static const float _hx_array_data_332f6459_2[] = {
	-0.5,-0.5,0.0,1.0,0.0,0.0,1.0,0.5,-0.5,0.0,0.0,1.0,0.0,1.0,0.0,0.5,0.0,0.0,0.0,1.0,1.0,
};
static const int _hx_array_data_332f6459_3[] = {
	(int)0,(int)1,(int)2,
};

void Main_obj::__construct() { }

Dynamic Main_obj::__CreateEmpty() { return new Main_obj; }

void *Main_obj::_hx_vtable = 0;

Dynamic Main_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Main_obj > _hx_result = new Main_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Main_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x07825a7d;
}

void Main_obj::main(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_7_main)
HXLINE(   8)		{
HXLINE(   8)			void();
HXDLIN(   8)			glfwInit();
            		}
HXLINE(   9)		::cpp::Pointer<  GLFWmonitor > tmp = null();
HXDLIN(   9)		::cpp::Pointer<  GLFWwindow > tmp1 = null();
HXDLIN(   9)		::cpp::Pointer<  GLFWwindow > window = glfwCreateWindow(800,600,HX_("Hello World",84,f6,db,6f),tmp,tmp1);
HXLINE(  10)		if (::hx::IsNull( window )) {
HXLINE(  11)			glfwTerminate();
HXLINE(  12)			return;
            		}
HXLINE(  15)		glfwMakeContextCurrent(window);
HXLINE(  18)		::Array< float > vertices = ::Array_obj< float >::fromData( _hx_array_data_332f6459_2,21);
HXLINE(  24)		::Array< int > indices = ::Array_obj< int >::fromData( _hx_array_data_332f6459_3,3);
HXLINE(  29)		 GsBackend * backend = gs_create_backend(gs_get_optimal_backend_type());
HXLINE(  32)		 GsConfig * config = gs_create_config();
HXLINE(  33)		(*(config)).backend = backend;
HXLINE(  36)		gs_init(config);
HXLINE(  39)		 GsCommandList * commandList = gs_create_command_list();
HXLINE(  42)		::String vertexShaderSource = HX_("\r\n            #version 460 core\r\n\r\n            layout(location = 0) in vec3 aPosition;\r\n            layout(location = 1) in vec4 aColour;\r\n            out vec4 vColour;\r\n\r\n            void main() {\r\n                gl_Position = vec4(aPosition, 1.0);\r\n                vColour = aColour;\r\n            }\r\n        ",f5,8b,e5,8c);
HXLINE(  55)		::String fragmentShaderSource = HX_("\r\n            #version 460 core\r\n\r\n            in vec4 vColour;\r\n            out vec4 fragColor;\r\n\r\n            void main() {\r\n                fragColor = vColour;\r\n            }\r\n        ",32,40,36,2d);
HXLINE(  66)		 GsShader * vertexShader = gs_create_shader(GS_SHADER_TYPE_VERTEX,vertexShaderSource.utf8_str());
HXLINE(  67)		 GsShader * fragmentShader = gs_create_shader(GS_SHADER_TYPE_FRAGMENT,fragmentShaderSource.utf8_str());
HXLINE(  70)		 GsProgram * program = gs_create_program();
HXLINE(  71)		gs_program_attach_shader(program,vertexShader);
HXLINE(  72)		gs_program_attach_shader(program,fragmentShader);
HXLINE(  73)		gs_program_build(program);
HXLINE(  76)		 GsVtxLayout * layout = gs_create_layout();
HXLINE(  77)		gs_layout_add(layout,0,GS_ATTRIB_TYPE_FLOAT,3);
HXLINE(  78)		gs_layout_add(layout,1,GS_ATTRIB_TYPE_FLOAT,4);
HXLINE(  79)		gs_layout_build(layout);
HXLINE(  82)		 GsPipeline * pipeline = gs_create_pipeline();
HXLINE(  83)		(*(pipeline)).layout = layout;
HXLINE(  84)		(*(pipeline)).program = program;
HXLINE(  87)		 GsBuffer * vertexBuffer = gs_create_buffer(GS_BUFFER_TYPE_VERTEX,GS_BUFFER_INTENT_DRAW_STATIC);
HXLINE(  88)		{
HXLINE(  88)			::cpp::Pointer< void > ptr = ( (::cpp::Pointer< float >)(::cpp::Pointer_obj::arrayElem(vertices,0)) )->reinterpret();
HXDLIN(  88)			 ::genesis::_GsManagedData::GsManagedDataHolder data = ::genesis::_GsManagedData::GsManagedData_Impl__obj::_new(ptr->ptr,(vertices->length * 4));
HXDLIN(  88)			gs_buffer_set_data(vertexBuffer,data->ptr,data->size);
            		}
HXLINE(  91)		 GsBuffer * indexBuffer = gs_create_buffer(GS_BUFFER_TYPE_INDEX,GS_BUFFER_INTENT_DRAW_STATIC);
HXLINE(  92)		{
HXLINE(  92)			::cpp::Pointer< void > ptr1 = ( (::cpp::Pointer< int >)(::cpp::Pointer_obj::arrayElem(indices,0)) )->reinterpret();
HXDLIN(  92)			 ::genesis::_GsManagedData::GsManagedDataHolder data1 = ::genesis::_GsManagedData::GsManagedData_Impl__obj::_new(ptr1->ptr,(indices->length * 4));
HXDLIN(  92)			gs_buffer_set_data(indexBuffer,data1->ptr,data1->size);
            		}
HXLINE(  94)		while((glfwWindowShouldClose(window) == 0)){
HXLINE(  95)			gs_command_list_begin(commandList);
HXLINE(  96)			gs_set_viewport(commandList,0,0,800,600);
HXLINE(  97)			gs_clear(commandList,(GsClearFlags)(1 | 2),( (Float)(0) ),( (Float)(0) ),( (Float)(0) ),( (Float)(1) ));
HXLINE(  98)			gs_use_pipeline(commandList,pipeline);
HXLINE(  99)			gs_use_buffer(commandList,vertexBuffer);
HXLINE( 100)			gs_use_buffer(commandList,indexBuffer);
HXLINE( 101)			gs_draw_indexed(commandList,3);
HXLINE( 102)			gs_command_list_end(commandList);
HXLINE( 104)			gs_command_list_submit(commandList);
HXLINE( 105)			gs_frame();
HXLINE( 107)			glfwSwapBuffers(window);
HXLINE( 108)			glfwPollEvents();
            		}
HXLINE( 112)		gs_destroy_command_list(commandList);
HXLINE( 113)		gs_destroy_pipeline(pipeline);
HXLINE( 114)		gs_destroy_layout(layout);
HXLINE( 115)		gs_destroy_buffer(vertexBuffer);
HXLINE( 116)		gs_destroy_buffer(indexBuffer);
HXLINE( 117)		gs_destroy_shader(vertexShader);
HXLINE( 118)		gs_destroy_shader(fragmentShader);
HXLINE( 119)		gs_destroy_program(program);
HXLINE( 122)		gs_shutdown();
HXLINE( 125)		gs_destroy_backend(backend);
HXLINE( 126)		gs_destroy_config(config);
HXLINE( 127)		glfwTerminate();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Main_obj,main,(void))


Main_obj::Main_obj()
{
}

bool Main_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"main") ) { outValue = main_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Main_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Main_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Main_obj::__mClass;

static ::String Main_obj_sStaticFields[] = {
	HX_("main",39,38,56,48),
	::String(null())
};

void Main_obj::__register()
{
	Main_obj _hx_dummy;
	Main_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Main",59,64,2f,33);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Main_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Main_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Main_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Main_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Main_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

